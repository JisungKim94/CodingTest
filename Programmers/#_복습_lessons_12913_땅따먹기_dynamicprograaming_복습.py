""" 
좀 더 직접적인 예시를 드리겠습니다.
[{1,2,6,7},{2,3,10,8},{1,3,9,4},{7,11,9,4}]
여기서 첫 행을 볼까요?
1, 2, 6, 7
각 열을 포함하는 최선은 1,2,6,7 입니다.
2,3,10,8 -> 2를 밟기 위해서는 1을 제외한 케이스입니다. 그 중 7이 명백히 다른 것 보다 우월합니다. -> 9. 마찬가지로 10, 17인데 8의 경우에는 최선이 3열을 밟은 케이스이므로 14가 됩니다. 즉 9,10,17,14.
1,3,9,4 -> 1을 밟을 때 최선은 이전의 10,17,14중 최댓값입니다. 합산은 18. 다른 것은 명백히 합이 적습니다. 마찬가지로 13, 마지막 열은 21인데 3열은 14가 최선으로 23이 됩니다. 즉 18,13,23,14가 됩니다.
7,11,9,4 -> 7을 밟을 때 최선은 이전의 13,23,14중 최댓값입니다. 합산은 30. 이하 비슷하게 34, 27, 27.
최종적으로 마지막 4행의 1열을 밟을 때 최선은 30. 2열을 밟을 때 최선은 34, 3열은 27, 4열도 27의 값이 합산의 최대값입니다. 또한 각 경우는 분명히 실존합니다.
따라서 최종적으로 최대값은 34가 되겠군요. 과정은 문제에서 요구하지 않았기에 딱히 구하지 않았지만, 구하려 한다면 이전의 행에서의 최선에 이제까지 밟아온 열의 정보를 함께 넣어주는 방식으로 넣어서 최선의 선택을 구할 수는 있습니다.
이 방법 그 어디에도 전전행을 고려하지 않습니다. 전전행에 대한 규칙이 없고, 이전 행에 대한 규칙만이 존재하니까요.
이전 행까지 규칙을 잘 지켰다면 전전행때문에 문제가 되는 일은 없는 것입니다.
수학적 귀납법과도 비슷하지요. N까지 잘 지켜졌다면, N+1 또한 지켜지는 규칙이며, 0/1에서 규칙을 지켰다면 모든 구간에서 규칙을 지켰다는 말 처럼 말입니다. 
"""


def solution(land):
    answer = 0
    for i in range(len(land)):
        if i == 0:
            continue
        for j in range(len(land[0])):
            temp = land[i - 1][j]
            # dynamic programming
            land[i - 1][j] = -1
            land[i][j] = land[i][j] + max(land[i - 1])
            land[i - 1][j] = temp

    answer = max(land[-1])
    print(answer)

    return answer


print(solution([[1, 2, 3, 5], [5, 6, 7, 8], [4, 3, 2, 1]]) == 16)
print(solution([[1, 2, 3, 5], [5, 6, 7, 8], [4, 3, 2, 1], [5, 3, 3, 1]]) == 20)
